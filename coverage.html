
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>services: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/EslamYasser-Dev/simple-file-share/application/services/download_file_service.go (0.0%)</option>
				
				<option value="file1">github.com/EslamYasser-Dev/simple-file-share/application/services/download_zip_service.go (0.0%)</option>
				
				<option value="file2">github.com/EslamYasser-Dev/simple-file-share/application/services/list_file_service.go (0.0%)</option>
				
				<option value="file3">github.com/EslamYasser-Dev/simple-file-share/application/services/upload_service.go (0.0%)</option>
				
				<option value="file4">github.com/EslamYasser-Dev/simple-file-share/cmd/server/main.go (0.0%)</option>
				
				<option value="file5">github.com/EslamYasser-Dev/simple-file-share/domain/errors/not_found.go (0.0%)</option>
				
				<option value="file6">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/handlers/download_handler.go (0.0%)</option>
				
				<option value="file7">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/handlers/list_handler.go (0.0%)</option>
				
				<option value="file8">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/handlers/root_handler.go (0.0%)</option>
				
				<option value="file9">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/handlers/upload_handler.go (0.0%)</option>
				
				<option value="file10">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/middleware.go (0.0%)</option>
				
				<option value="file11">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/server.go (0.0%)</option>
				
				<option value="file12">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/upload_part_adapter.go (0.0%)</option>
				
				<option value="file13">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/auth/static_auth_provider.go (0.0%)</option>
				
				<option value="file14">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/config/env_config_provider.go (0.0%)</option>
				
				<option value="file15">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/fs/local_file_repository.go (0.0%)</option>
				
				<option value="file16">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/logging/std_logger.go (0.0%)</option>
				
				<option value="file17">github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/tls/in_memory_cert_gen.go (0.0%)</option>
				
				<option value="file18">github.com/EslamYasser-Dev/simple-file-share/infrastructure/utils/zip_writer.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package services

import (
        "github.com/EslamYasser-Dev/simple-file-share/domain/errors"
        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

type DownloadFileService struct {
        fileRepo ports.FileRepository
}

func NewDownloadFileService(fileRepo ports.FileRepository) *DownloadFileService <span class="cov0" title="0">{
        return &amp;DownloadFileService{fileRepo: fileRepo}
}</span>

func (s *DownloadFileService) Execute(path string) (models.ReadCloser, string, error) <span class="cov0" title="0">{
        exists, err := s.fileRepo.FileExists(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return nil, "", &amp;errors.NotFoundError{Path: path}
        }</span>

        <span class="cov0" title="0">isDir, err := s.fileRepo.IsDirectory(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">if isDir </span><span class="cov0" title="0">{
                return nil, "", nil // Delegate to list or zip
        }</span>

        <span class="cov0" title="0">return s.fileRepo.ServeFile(path)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package services

import (
        "path/filepath"

        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

type DownloadZipService struct {
        fileRepo ports.FileRepository
}

func NewDownloadZipService(fileRepo ports.FileRepository) *DownloadZipService <span class="cov0" title="0">{
        return &amp;DownloadZipService{fileRepo: fileRepo}
}</span>

func (s *DownloadZipService) Execute(path string) (models.ReadCloser, string, error) <span class="cov0" title="0">{
        isDir, err := s.fileRepo.IsDirectory(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">if !isDir </span><span class="cov0" title="0">{
                return nil, "", nil // Not a dir → not zip
        }</span>

        <span class="cov0" title="0">zipStream, err := s.fileRepo.ZipDirectory(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">return zipStream, filepath.Base(path) + ".zip", nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

type ListFilesService struct {
        fileRepo ports.FileRepository
}

func NewListFilesService(fileRepo ports.FileRepository) *ListFilesService <span class="cov0" title="0">{
        return &amp;ListFilesService{fileRepo: fileRepo}
}</span>

func (s *ListFilesService) Execute(path string) (*models.PageData, error) <span class="cov0" title="0">{
        isDir, err := s.fileRepo.IsDirectory(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isDir </span><span class="cov0" title="0">{
                return nil, nil // Not a directory → delegate to download
        }</span>

        <span class="cov0" title="0">files, err := s.fileRepo.ListDirectory(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;models.PageData{Root: path, Files: files}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package services

import (
        "path/filepath"

        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

type UploadService struct {
        fileRepo ports.FileRepository
}

func NewUploadService(fileRepo ports.FileRepository) *UploadService <span class="cov0" title="0">{
        return &amp;UploadService{fileRepo: fileRepo}
}</span>

func (s *UploadService) Execute(parts []models.UploadPart) ([]models.FileUpload, error) <span class="cov0" title="0">{
        var uploads []models.FileUpload

        for _, part := range parts </span><span class="cov0" title="0">{
                filename := part.Filename()
                if filename == "" </span><span class="cov0" title="0">{
                        part.Content().Close()
                        continue</span>
                }

                <span class="cov0" title="0">dir := filepath.Dir(filename)
                if err := s.fileRepo.CreateDirectory(dir); err != nil </span><span class="cov0" title="0">{
                        part.Content().Close()
                        continue</span>
                }

                <span class="cov0" title="0">written, err := s.fileRepo.WriteFile(filename, part.Content())
                if err != nil </span><span class="cov0" title="0">{
                        part.Content().Close()
                        continue</span>
                }

                <span class="cov0" title="0">uploads = append(uploads, models.FileUpload{
                        Filename: filename,
                        Size:     written,
                })</span>
        }

        <span class="cov0" title="0">return uploads, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "log"

        "github.com/EslamYasser-Dev/simple-file-share/application/services"
        xhttp "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http"
        "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http/handlers"
        "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/config"
        "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/fs"
        "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/logging"
        "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/secondary/tls"
)

func main() <span class="cov0" title="0">{
        // === CONFIG ===
        cfg, err := config.NewEnvConfigProvider()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to load config: ", err)
        }</span>

        // === LOGGING ===
        <span class="cov0" title="0">logger := logging.NewStdLogger()

        // === SECONDARY ADAPTERS ===
        fileRepo := fs.NewLocalFileRepository(cfg.GetRootDir())
        // authProvider := auth.NewStaticAuthProvider(cfg.GetUsername(), cfg.GetPassword())
        tlsGenerator := &amp;tls.InMemoryTLSCertGenerator{}

        // === APPLICATION SERVICES ===
        listService := services.NewListFilesService(fileRepo)
        downloadService := services.NewDownloadFileService(fileRepo)
        zipService := services.NewDownloadZipService(fileRepo)
        uploadService := services.NewUploadService(fileRepo)

        // === PRIMARY ADAPTERS (HTTP HANDLERS) ===
        rootHandler := handlers.NewRootHandler(listService, downloadService, zipService, cfg.GetPort())
        uploadHandler := handlers.NewUploadHandler(uploadService)

        // === HTTP SERVER ===
        server := xhttp.NewServer(
                cfg.GetPort(),
                tlsGenerator,
                logger,
                rootHandler,
                uploadHandler,
        )

        // === START ===
        if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Server failed", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package errors

type NotFoundError struct {
        Path string
}

func (e *NotFoundError) Error() string <span class="cov0" title="0">{
        return "path not found: " + e.Path
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "fmt"
        "io"
        "net/http"
        "path/filepath"
        "strings"

        "github.com/EslamYasser-Dev/simple-file-share/domain/errors"

        "github.com/EslamYasser-Dev/simple-file-share/application/services"
)

// DownloadHandler handles file and directory ZIP downloads.
type DownloadHandler struct {
        fileService *services.DownloadFileService
        zipService  *services.DownloadZipService
}

// NewDownloadHandler creates a new DownloadHandler.
func NewDownloadHandler(fileService *services.DownloadFileService, zipService *services.DownloadZipService) *DownloadHandler <span class="cov0" title="0">{
        return &amp;DownloadHandler{
                fileService: fileService,
                zipService:  zipService,
        }
}</span>

// ServeHTTP determines whether to serve a file or a ZIP archive.
func (h *DownloadHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        path := cleanPath(r.URL.Path)
        if containsPathTraversal(path) </span><span class="cov0" title="0">{
                http.Error(w, "Path traversal detected", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">isZipRequest := strings.HasSuffix(path, ".zip")
        if isZipRequest </span><span class="cov0" title="0">{
                path = strings.TrimSuffix(path, ".zip")
                stream, filename, err := h.zipService.Execute(path)
                if err != nil </span><span class="cov0" title="0">{
                        respondWithError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">if stream == nil </span><span class="cov0" title="0">{
                        http.Error(w, "Not a directory", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">serveDownload(w, stream, filename, "application/zip")
                return</span>
        }

        <span class="cov0" title="0">stream, filename, err := h.fileService.Execute(path)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, err)
                return
        }</span>
        <span class="cov0" title="0">if stream == nil </span><span class="cov0" title="0">{
                http.Error(w, "Is a directory", http.StatusConflict)
                return
        }</span>
        <span class="cov0" title="0">serveDownload(w, stream, filename, "application/octet-stream")</span>
}

// serveDownload writes stream to HTTP response with headers.
func serveDownload(w http.ResponseWriter, stream io.ReadCloser, filename, contentType string) <span class="cov0" title="0">{
        defer stream.Close()
        w.Header().Set("Content-Type", contentType)
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", filename))
        if _, err := io.Copy(w, stream); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Stream copy failed", http.StatusInternalServerError)
        }</span>
}

// respondWithError maps domain errors to HTTP status codes.
func respondWithError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        if _, ok := err.(*errors.NotFoundError); ok </span><span class="cov0" title="0">{
                http.Error(w, "Not Found", http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">http.Error(w, "Internal Server Error", http.StatusInternalServerError)</span>
}

// cleanPath normalizes path for security and consistency.
func cleanPath(p string) string <span class="cov0" title="0">{
        if p == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>
        <span class="cov0" title="0">return filepath.ToSlash(p)</span>
}

// containsPathTraversal checks for dangerous path patterns.
func containsPathTraversal(p string) bool <span class="cov0" title="0">{
        return strings.Contains(p, "..")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "net/http"

        "github.com/EslamYasser-Dev/simple-file-share/application/services"
)

// ListHandler handles requests to list directory contents.
type ListHandler struct {
        listService *services.ListFilesService
        port        string
}

// NewListHandler creates a new ListHandler.
func NewListHandler(listService *services.ListFilesService, port string) *ListHandler <span class="cov0" title="0">{
        return &amp;ListHandler{
                listService: listService,
                port:        port,
        }
}</span>

// ServeHTTP serves directory listing or delegates if not a directory.
func (h *ListHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        path := cleanPath(r.URL.Path)
        if containsPathTraversal(path) </span><span class="cov0" title="0">{
                http.Error(w, "Path traversal detected", http.StatusForbidden)
                return
        }</span>

        <span class="cov0" title="0">pageData, err := h.listService.Execute(path)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if pageData == nil </span><span class="cov0" title="0">{
                // Not a directory — should be handled by download handler in router
                http.Error(w, "Not a directory", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">pageData.Port = h.port</span>
        // if err := frontend.Tpl.Execute(w, pageData); err != nil {
        //         http.Error(w, "Template render failed", http.StatusInternalServerError)
        // }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
    "net/http"
    "strings"

    "github.com/EslamYasser-Dev/simple-file-share/application/services"
)

// RootHandler decides between directory listing and file/zip download for GET "/".
type RootHandler struct {
        listService     *services.ListFilesService
        fileService     *services.DownloadFileService
        zipService      *services.DownloadZipService
        port            string
}

func NewRootHandler(list *services.ListFilesService, file *services.DownloadFileService, zip *services.DownloadZipService, port string) *RootHandler <span class="cov0" title="0">{
        return &amp;RootHandler{listService: list, fileService: file, zipService: zip, port: port}
}</span>

func (h *RootHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        path := cleanPath(r.URL.Path)
        if containsPathTraversal(path) </span><span class="cov0" title="0">{
                http.Error(w, "Path traversal detected", http.StatusForbidden)
                return
        }</span>

        // ZIP request
        <span class="cov0" title="0">if strings.HasSuffix(path, ".zip") </span><span class="cov0" title="0">{
                path = strings.TrimSuffix(path, ".zip")
                stream, filename, err := h.zipService.Execute(path)
                if err != nil </span><span class="cov0" title="0">{
                        respondWithError(w, err)
                        return
                }</span>
                <span class="cov0" title="0">if stream == nil </span><span class="cov0" title="0">{
                        http.Error(w, "Not a directory", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">serveDownload(w, stream, filename, "application/zip")
                return</span>
        }

        // Try as directory first
        <span class="cov0" title="0">pageData, err := h.listService.Execute(path)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">if pageData != nil </span><span class="cov0" title="0">{
                pageData.Port = h.port
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte("Directory listing available via API. Integrate template to render UI."))
                return
        }</span>

        // Fallback: serve as file
        <span class="cov0" title="0">stream, filename, err := h.fileService.Execute(path)
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, err)
                return
        }</span>
        <span class="cov0" title="0">if stream == nil </span><span class="cov0" title="0">{
                http.Error(w, "Is a directory", http.StatusConflict)
                return
        }</span>
        <span class="cov0" title="0">serveDownload(w, stream, filename, "application/octet-stream")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "fmt"
        "html"
        "io"
        "net/http"

        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
        xhttp "github.com/EslamYasser-Dev/simple-file-share/infrastructure/adapters/primary/http"

        "github.com/EslamYasser-Dev/simple-file-share/application/services"
)

// UploadHandler handles multipart file uploads.
type UploadHandler struct {
        uploadService *services.UploadService
}

// NewUploadHandler creates a new UploadHandler.
func NewUploadHandler(uploadService *services.UploadService) *UploadHandler <span class="cov0" title="0">{
        return &amp;UploadHandler{
                uploadService: uploadService,
        }
}</span>

// ServeHTTP processes uploaded files and returns HTML response.
func (h *UploadHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">reader, err := r.MultipartReader()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid multipart request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var parts []models.UploadPart
        for </span><span class="cov0" title="0">{
                part, err := reader.NextPart()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip malformed parts
                }
                <span class="cov0" title="0">parts = append(parts, &amp;xhttp.UploadPartAdapter{Part: part})</span>
        }

        <span class="cov0" title="0">uploads, err := h.uploadService.Execute(parts)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Upload processing failed", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">renderUploadResponse(w, uploads)</span>
}

// renderUploadResponse generates HTML feedback for uploaded files.
func renderUploadResponse(w http.ResponseWriter, uploads []models.FileUpload) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html; charset=utf-8")

        if len(uploads) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(w, `
                        &lt;!DOCTYPE html&gt;
                        &lt;html&gt;
                        &lt;head&gt;&lt;title&gt;Upload Result&lt;/title&gt;&lt;/head&gt;
                        &lt;body&gt;
                                &lt;h3&gt;⚠️ No files were uploaded!&lt;/h3&gt;
                                &lt;p&gt;Please go back and select a file or folder.&lt;/p&gt;
                                &lt;a href="/"&gt;📁 Back to files&lt;/a&gt;
                        &lt;/body&gt;
                        &lt;/html&gt;`)
                return
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(w, `
                &lt;!DOCTYPE html&gt;
                &lt;html&gt;
                &lt;head&gt;&lt;title&gt;Upload Result&lt;/title&gt;&lt;/head&gt;
                &lt;body&gt;
                        &lt;h3&gt;✅ Successfully uploaded %d file(s)!&lt;/h3&gt;
                        &lt;ul&gt;`, len(uploads))

        for _, upload := range uploads </span><span class="cov0" title="0">{
                safeName := html.EscapeString(upload.Filename)
                fmt.Fprintf(w, `&lt;li&gt;%s (%d bytes)&lt;/li&gt;`, safeName, upload.Size)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(w, `
                        &lt;/ul&gt;
                        &lt;a href="/"&gt;📁 Back to files&lt;/a&gt;
                &lt;/body&gt;
                &lt;/html&gt;`)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package xhttp

import (
        "net/http"

        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

// AuthMiddleware returns an HTTP middleware that enforces Basic Auth.
// It uses the domain.AuthProvider port to validate credentials.
func AuthMiddleware(authProvider ports.AuthProvider) func(next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(next http.HandlerFunc) http.HandlerFunc </span><span class="cov0" title="0">{
                return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        user, pass, ok := r.BasicAuth()
                        if !ok || !authProvider.Authenticate(user, pass) </span><span class="cov0" title="0">{
                                w.Header().Set("WWW-Authenticate", `Basic realm="Restricted"`)
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">next(w, r)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package xhttp

import (
        "context"
        "crypto/tls"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        _ "embed"

        "github.com/EslamYasser-Dev/simple-file-share/api"
        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

type Server struct {
        port            string
        tlsGenerator    ports.TLSCertGenerator
        logger          ports.Logger
        rootHandler     http.Handler
        uploadHandler   http.Handler
        httpServer      *http.Server
}

func NewServer(
        port string,
        tlsGen ports.TLSCertGenerator,
        logger ports.Logger,
        rootHandler, uploadHandler http.Handler,
) *Server <span class="cov0" title="0">{
        server := &amp;http.Server{
                Addr: ":" + port,
                TLSConfig: &amp;tls.Config{
                        Certificates:             nil,
                        MinVersion:               tls.VersionTLS13,
                        CurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},
                        PreferServerCipherSuites: true,
                },
                ReadTimeout:    24 * time.Hour,
                WriteTimeout:   24 * time.Hour,
                MaxHeaderBytes: 1 &lt;&lt; 20,
        }

        return &amp;Server{
                port:            port,
                tlsGenerator:    tlsGen,
                logger:          logger,
                rootHandler:     rootHandler,
                uploadHandler:   uploadHandler,
                httpServer:      server,
        }
}</span>

// Start initializes TLS and starts listening with graceful shutdown.
func (s *Server) Start() error <span class="cov0" title="0">{
        mux := s.registerRoutes()
        s.httpServer.Handler = mux

        certPEM, keyPEM, err := s.tlsGenerator.GenerateCert()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate TLS certificate: %w", err)
        }</span>

        <span class="cov0" title="0">cert, err := tls.X509KeyPair(certPEM, keyPEM)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse TLS key pair: %w", err)
        }</span>

        <span class="cov0" title="0">s.httpServer.TLSConfig.Certificates = []tls.Certificate{cert}

        // Create context for shutdown
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                s.logger.Info("HTTPS server starting", "address", "https://0.0.0.0:"+s.port)
                if err := s.httpServer.ListenAndServeTLS("", ""); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.Fatal("Server failed", "error", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">&lt;-ctx.Done()
        s.logger.Info("Shutdown signal received, gracefully stopping server...")

        // Give active connections 10 seconds to finish
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := s.httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Server forced to shutdown", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("Server exited gracefully")
        return nil</span>
}

// registerRoutes maps URL paths to handlers and returns a mux.
func (s *Server) registerRoutes() *http.ServeMux <span class="cov0" title="0">{
        mux := http.NewServeMux()
        mux.Handle("/", s.rootHandler)
        mux.Handle("/upload", s.uploadHandler)

        mux.HandleFunc("/swagger.yaml", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/yaml")
                w.Write(api.SwaggerSpec)
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/swagger", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/html")
                w.Write([]byte(`
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;Swagger UI&lt;/title&gt;
        &lt;link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@4/swagger-ui.css" /&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id="swagger-ui"&gt;&lt;/div&gt;
        &lt;script src="https://unpkg.com/swagger-ui-dist@4/swagger-ui-bundle.js"&gt;&lt;/script&gt;
        &lt;script&gt;
          SwaggerUIBundle({
            url: '/swagger.yaml',
            dom_id: '#swagger-ui',
          })
        &lt;/script&gt;
      &lt;/body&gt;
    &lt;/html&gt;`))
        }</span>)
        <span class="cov0" title="0">return mux</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package xhttp

import (
        "mime/multipart"

        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
)

// UploadPartAdapter adapts *multipart.Part to domain.UploadPart.
// This is an Anti-Corruption Layer between HTTP multipart and domain.
type UploadPartAdapter struct {
        Part *multipart.Part
}

// Filename returns the original filename from the HTTP form.
func (upa *UploadPartAdapter) Filename() string <span class="cov0" title="0">{
        return upa.Part.FileName()
}</span>

// Content returns the file content stream as domain.ReadCloser.
func (upa *UploadPartAdapter) Content() models.ReadCloser <span class="cov0" title="0">{
        return upa.Part
}</span>

// Ensure *multipart.Part implements domain.ReadCloser (it does via embedded io.Reader + Close())
var _ models.ReadCloser = (*multipart.Part)(nil)
</pre>
		
		<pre class="file" id="file13" style="display: none">package auth

import "github.com/EslamYasser-Dev/simple-file-share/domain/ports"

// StaticAuthProvider implements simple static credential authentication.
type StaticAuthProvider struct {
        username string
        password string
}

// NewStaticAuthProvider creates a new auth provider with given credentials.
func NewStaticAuthProvider(username, password string) *StaticAuthProvider <span class="cov0" title="0">{
        return &amp;StaticAuthProvider{
                username: username,
                password: password,
        }
}</span>

// Authenticate validates username and password.
func (p *StaticAuthProvider) Authenticate(username, password string) bool <span class="cov0" title="0">{
        return username == p.username &amp;&amp; password == p.password
}</span>

var _ ports.AuthProvider = (*StaticAuthProvider)(nil)
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "os"

        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

// EnvConfigProvider reads configuration from environment variables.
type EnvConfigProvider struct {
        port     string
        username string
        password string
        rootDir  string
}

// NewEnvConfigProvider creates a config provider with defaults.
func NewEnvConfigProvider() (*EnvConfigProvider, error) <span class="cov0" title="0">{
        rootDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;EnvConfigProvider{
                port:     getEnv("PORT", "22010"),
                username: getEnv("USERNAME", "admin"),
                password: getEnv("PASSWORD", "thisone"),
                rootDir:  rootDir,
        }, nil</span>
}

func (p *EnvConfigProvider) GetPort() string     <span class="cov0" title="0">{ return p.port }</span>
func (p *EnvConfigProvider) GetUsername() string <span class="cov0" title="0">{ return p.username }</span>
func (p *EnvConfigProvider) GetPassword() string <span class="cov0" title="0">{ return p.password }</span>
func (p *EnvConfigProvider) GetRootDir() string  <span class="cov0" title="0">{ return p.rootDir }</span>

// getEnv returns env var value or fallback.
func getEnv(key, fallback string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}

var _ ports.ConfigProvider = (*EnvConfigProvider)(nil)
</pre>
		
		<pre class="file" id="file15" style="display: none">package fs

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/EslamYasser-Dev/simple-file-share/domain/models"
        "github.com/EslamYasser-Dev/simple-file-share/infrastructure/utils"
)

// LocalFileRepository implements domain.FileRepository using local filesystem.
type LocalFileRepository struct {
        rootDir string
}

// NewLocalFileRepository creates a new file repository adapter.
func NewLocalFileRepository(rootDir string) *LocalFileRepository <span class="cov0" title="0">{
        return &amp;LocalFileRepository{rootDir: rootDir}
}</span>

// resolve converts a relative path to absolute within rootDir.
func (r *LocalFileRepository) resolve(path string) string <span class="cov0" title="0">{
        cleaned := filepath.FromSlash(strings.TrimPrefix(path, "/"))
        return filepath.Join(r.rootDir, cleaned)
}</span>

// ListDirectory returns metadata for all entries in a directory.
func (r *LocalFileRepository) ListDirectory(path string) ([]*models.FileInfo, error) <span class="cov0" title="0">{
        fullPath := r.resolve(path)
        entries, err := os.ReadDir(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var files []*models.FileInfo
        for _, entry := range entries </span><span class="cov0" title="0">{
                name := entry.Name()
                url := "/" + filepath.ToSlash(filepath.Join(strings.TrimPrefix(path, "/"), name))
                zipURL := url + ".zip"
                if path == "/" || path == "" </span><span class="cov0" title="0">{
                        url = "/" + name
                        zipURL = "/" + name + ".zip"
                }</span>

                <span class="cov0" title="0">fileInfo, _ := entry.Info()
                size := formatFileSize(fileInfo.Size(), entry.IsDir())

                files = append(files, &amp;models.FileInfo{
                        Name:   name,
                        URL:    url,
                        ZipURL: zipURL,
                        Size:   size,
                        IsDir:  entry.IsDir(),
                })</span>
        }
        <span class="cov0" title="0">return files, nil</span>
}

// IsDirectory checks if the path is a directory.
func (r *LocalFileRepository) IsDirectory(path string) (bool, error) <span class="cov0" title="0">{
        info, err := os.Stat(r.resolve(path))
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return info.IsDir(), nil</span>
}

// FileExists checks if a file or directory exists at the given path.
func (r *LocalFileRepository) FileExists(path string) (bool, error) <span class="cov0" title="0">{
        _, err := os.Stat(r.resolve(path))
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return err == nil, err</span>
}

// ServeFile opens a file for reading and returns its stream and name.
func (r *LocalFileRepository) ServeFile(path string) (models.ReadCloser, string, error) <span class="cov0" title="0">{
        fullPath := r.resolve(path)
        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">return file, filepath.Base(fullPath), nil</span>
}

// CreateDirectory creates all directories in the given path.
func (r *LocalFileRepository) CreateDirectory(path string) error <span class="cov0" title="0">{
        return os.MkdirAll(r.resolve(path), 0755)
}</span>

// WriteFile writes content from reader to the specified file path.
func (r *LocalFileRepository) WriteFile(path string, reader models.ReadCloser) (int64, error) <span class="cov0" title="0">{
        defer reader.Close()

        fullPath := r.resolve(path)
        if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">dst, err := os.Create(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        return io.Copy(dst, reader)</span>
}

// ZipDirectory returns a streaming ZIP archive of the directory.
func (r *LocalFileRepository) ZipDirectory(root string) (models.ReadCloser, error) <span class="cov0" title="0">{
        pr, pw := io.Pipe()

        go func() </span><span class="cov0" title="0">{
                defer pw.Close()
                if err := utils.ZipDirectory(r.resolve(root), pw); err != nil </span><span class="cov0" title="0">{
                        pw.CloseWithError(err)
                }</span>
        }()

        <span class="cov0" title="0">return pr, nil</span>
}

// formatFileSize returns human-readable size string.
func formatFileSize(size int64, isDir bool) string <span class="cov0" title="0">{
        if isDir </span><span class="cov0" title="0">{
                return "[Directory]"
        }</span>
        <span class="cov0" title="0">const unit = 1024
        if size &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", size)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := size / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %ciB", float64(size)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package logging

import (
        "log"
        "sync"

        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

// StdLogger implements domain.Logger using Go's standard log.
type StdLogger struct {
        mu sync.Mutex // thread-safe
}

// NewStdLogger creates a new standard logger.
func NewStdLogger() *StdLogger <span class="cov0" title="0">{
        return &amp;StdLogger{}
}</span>

// Info logs an informational message.
func (l *StdLogger) Info(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.log("INFO", msg, keysAndValues...)
}</span>

// Error logs an error message.
func (l *StdLogger) Error(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.log("ERROR", msg, keysAndValues...)
}</span>

// Fatal logs a fatal message and exits.
func (l *StdLogger) Fatal(msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        log.Fatalf("FATAL: "+msg, keysAndValues...)
}</span>

// log writes a formatted log entry.
func (l *StdLogger) log(level, msg string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        l.mu.Lock()
        defer l.mu.Unlock()

        if len(keysAndValues) == 0 </span><span class="cov0" title="0">{
                log.Printf("%s: %s", level, msg)
                return
        }</span>

        // Simple key=value formatting
        <span class="cov0" title="0">var args []interface{}
        format := "%s: " + msg
        args = append(args, level)

        for i := 0; i &lt; len(keysAndValues); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(keysAndValues) </span><span class="cov0" title="0">{
                        format += " %v=%v"
                        args = append(args, keysAndValues[i], keysAndValues[i+1])
                }</span> else<span class="cov0" title="0"> {
                        format += " %v=&lt;missing&gt;"
                        args = append(args, keysAndValues[i])
                }</span>
        }

        <span class="cov0" title="0">log.Printf(format, args...)</span>
}

var _ ports.Logger = (*StdLogger)(nil)
</pre>
		
		<pre class="file" id="file17" style="display: none">package tls

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/pem"
        "fmt"
        "math/big"
        "net"
        "time"

        "github.com/EslamYasser-Dev/simple-file-share/domain/ports"
)

// InMemoryTLSCertGenerator generates self-signed TLS certificates in memory.
type InMemoryTLSCertGenerator struct{}

// GenerateCert creates a new self-signed certificate and private key.
func (g *InMemoryTLSCertGenerator) GenerateCert() ([]byte, []byte, error) <span class="cov0" title="0">{
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate RSA key: %w", err)
        }</span>

        <span class="cov0" title="0">serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate serial number: %w", err)
        }</span>

        <span class="cov0" title="0">notBefore := time.Now()
        notAfter := notBefore.Add(365 * 24 * time.Hour)

        template := x509.Certificate{
                SerialNumber: serialNumber,
                Subject: pkix.Name{
                        Organization: []string{"Go File Server"},
                        CommonName:   "localhost",
                },
                NotBefore:             notBefore,
                NotAfter:              notAfter,
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
                IPAddresses: []net.IP{
                        net.ParseIP("127.0.0.1"),
                        net.ParseIP("::1"),
                },
                DNSNames: []string{
                        "localhost",
                        "127.0.0.1",
                        "go-server.local",
                },
        }

        derBytes, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;privateKey.PublicKey, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create certificate: %w", err)
        }</span>

        <span class="cov0" title="0">certPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
        keyPEM := pem.EncodeToMemory(&amp;pem.Block{Type: "RSA PRIVATE KEY", Bytes: x509.MarshalPKCS1PrivateKey(privateKey)})

        return certPEM, keyPEM, nil</span>
}

var _ ports.TLSCertGenerator = (*InMemoryTLSCertGenerator)(nil)
</pre>
		
		<pre class="file" id="file18" style="display: none">package utils

import (
        "archive/zip"
        "io"
        "os"
        "path/filepath"
)

// ZipDirectory recursively zips a directory and writes to w.
// Designed to be used in a goroutine with io.Pipe().
func ZipDirectory(root string, w io.Writer) error <span class="cov0" title="0">{
        zipWriter := zip.NewWriter(w)
        defer zipWriter.Close()

        return filepath.Walk(root, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(root, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">header, err := zip.FileInfoHeader(info)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">header.Name = filepath.ToSlash(relPath)
                if info.IsDir() </span><span class="cov0" title="0">{
                        header.Name += "/"
                }</span>
                <span class="cov0" title="0">header.Method = zip.Deflate

                writer, err := zipWriter.CreateHeader(header)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !info.IsDir() </span><span class="cov0" title="0">{
                        file, err := os.Open(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer file.Close()
                        _, err = io.Copy(writer, file)
                        return err</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
